# Mine Sweeper

- 2022.4.29: 개발 시작, 기능 구현 완료
- 2022.4.30: README.md 작성, CSS style 수정

---

## Previews

---

## 실행 방법

1. 터미널을 열어 프로젝트를 다운로드할 위치 경로로 이동합니다.
2. `git clone https://github.com/peppermintc/mine-sweeper.git` 명령어로 프로젝트를 클론합니다.
3. `yarn install` 명령어로 node_modules를 설치합니다.
4. `yarn start` 명령어로 클라이언트 서버를 실행합니다.

---

## 사용 기술

- Create React App
- TypeScript
- Styled Components
- Prettier

---

## 프로젝트 설명

### 1. 게임 설명

### 2. 안내사항

### 3, 폴더 구조

### 4. 컴포넌트 종류

### 5. 상태 값

### 6. 구조 트리

---

## 구현 후 정리

### 개발하며 중요시 생각했던 점

- 파악이 어려운 변수, 함수 네이밍을 피하고 비슷한 유형끼리 유사성이 있도록 네이밍하기
- 타입스크립트 타입 정의를 코드 파악에 도움이 될 정도로 사용했는지
- 파일들의 코드 스타일이 일관성있는지
- 평소 자유로운 커밋 메시지를 작성하였으나 커밋 메시지에 라벨을 추가
- 커밋을 알아보기 쉬운 단위로 분리

---

### Redux를 사용하지 않았던 선택에 대하여

#### 1. Prop drilling 측면으로는 불필요

Prop drilling 최대 depth가 두단계로 깊지 않았고 (`App > MineBoard > Cell`) 컴포넌트 Props들을 읽음으로써 컴포넌트 파악에 도움이 될 수도 있다는 측면에서는 좋은 선택이었던 것 같습니다.

```HTML
예) <CompleteModal updateRankData={updateRankData} updateGameState={updateGameState} ... />

// 컴포넌트 코드 내부를 확인하기 전에 수행하는 작업을 예측할 수 있음
```

#### 2. 코드 작성 번거로움 측면으로는 필요

컴포넌트에 Props로 값들을 전달하는 경우가 많아지다보니 새롭게 Props로 전달할 값을 추가할 때마다 3곳(`JSX`, `interface`, `component file`)에 코드를 추가해야하는 작은 번거로움이 있었고 JSX 코드 라인이 늘어났습니다.

<img src="./previews/propAdding.png" alt="example" />

만약 Redux를 사용했다면 이것에 대한 부담은 조금 덜었을 수도 있을 것 같습니다.

#### 결론

앱의 기능이 조금만 커져도 전역상태관리 라이브러리를 사용하는 것이 좋겠다는 생각이 들었습니다.

---

### 게임 성공 조건 정의

보드 안의 한 칸 단위인 셀을 클릭하면 `mineBoard` 배열을 업데이트하도록 구현하였습니다. `mineBoard` 배열의 업데이트를 useEffect hook으로 감지하여서 감지될 때마다 게임 성공여부를 체크하도록 하였습니다. 성공 여부 체크를 위해서 성공 조건을 명확하게 정의해야했습니다. 정의한 성공 조건은 2가지입니다. 지뢰가 아닌 셀을 모두 찾아낸 경우와 모든 지뢰 위에 깃발을 꽂은 경우입니다.

#### 1. 지뢰가 아닌 셀을 모두 찾아낸 경우

셀 클릭시 지뢰가 아니면 `cellState`값이 number 타입으로 바뀝니다. 그렇기 때문에 number 타입을 가진 셀은 확정적으로 지뢰가 아닌 셀이고 이것을 카운트해서 `(전체 셀 개수 - 전체 지뢰 개수)`와 같을 경우 성공으로 체크하도록 로직을 구현하였습니다.

(`util 폴더의 checkComplete.foundAllNone 함수`)

#### 2. 모든 지뢰 위에 깃발을 꽂은 경우

원본 지뢰보드(`MINE_BOARD_ORIGINAL`)와 현재 사용 중인 복사본 지뢰보드(`mineBoard`)의 값을 비교해서 `flag`를 `mine`에 정확하게 꽂은 경우를 카운트하였습니다. 정확하게 깃발을 꽂은 경우가 지뢰의 총 개수와 같다면 성공으로 체크하는 로직입니다. 매번 보드 업데이트시마다 이 경우를 체크하는 것은 효율적이지 않아서 깃발을 최대로 꽂아서 남은 지뢰 개수 카운트가 0이 되었을 때만 이 경우를 체크하도록 하였습니다.(App 컴포넌트의 useEffect 사용부에서 확인 가능합니다)

(`util 폴더의 checkComplete.foundAllMine 함수`)

---

### 구현 시작 전 설계에 대한 후기

과제 가이드라인을 읽고 바로 코드 작성을 시작하지 않고 설계하는 시간을 가졌습니다. 사전 설계가 생산성이나 프로젝트 구조 측면에서 많은 도움이 되었습니다.

#### 1. 설계 내용

프로젝트 설계를 할 때는 전달받은 가이드라인을 바탕으로 3가지 항목으로 나누어 설계를 진행하였습니다.

1. 컴포넌트 설계: 어떤 컴포넌트들을 구현할지 적절한 네이밍과 함께 리스트로 작성해보았습니다. 실제 구현 단계에서 미리 계획했던 이 컴포넌트 설계 명세를 수시로 확인하면서 다음 수행할 작업을 인지할 수 있었고 개발 방향을 잃지 않는데 도움이 많이 되었습니다.

2. 상태 값 설계: 키 포인트가 될 상태 값들, 그리고 전역적으로 관리해야될 상태 값들을 정의해보았습니다. 초기 설계 단계에서 타입스크립트에서 타입을 정의하는 것과 유사하게 작성하였습니다. 이후 점점 더 나은 구조 및 변수명으로 업데이트하면서 개선과 구현을 번갈아가면서 진행하였습니다.

3. 구현 순서 설계: 핵심 기능부터 구현하고 부수적인 기능을 구현하는 순서로 계획하였습니다. 큰 틀에서 보면 설계를 따랐지만 설계 초기에 정했던 순서와는 실제와 많이 다르게 진행되었습니다. 실제 구현하면서는 기능 단위로 먼저 필요한 뷰 컴포넌트를 간단하게 구현한 후 기능적인 로직을 구현하는 순서로 진행하였습니다. 향후 설계에 뷰 구현과 기능 구현을 분리된 단계로 생각하고 설계한다면 도움이 될 것 같습니다.

#### 2. 느낀점

사전 설계와 완벽히 일치하도록 구현하지는 않았습니다. 하지만 설계는 완전히 똑같이 만들어내려고 수행하는 것이 아니라는 것을 알 수 있었습니다. 체감한 가장 큰 효용은 생산성의 증가였습니다. 미리 계획한 컴포넌트, 상태 값, 구현 순서들을 참고하는 것만으로도 도중에 다음 구현은 무엇을 해야하는지 고민하는 시간이 현저히 줄어들었습니다. 그리고 계획한 내용을 업데이트하며 프로젝트를 쌓아올리는 느낌을 받을 수 있었습니다.

---

🙂 아래 내용은 실제 구현과 달라진 점이 많아 읽는 것은 불필요합니다

## 구현 시작 전

### 1. 컴포넌트 설계

구현 시작 전 요구 사항 구현에 필요한 컴포넌트들이 무엇이 있을까 생각해보았습니다.

- `MineSweeper`: 지뢰찾기 8X8 컨테이너
  - `Cell`: 지뢰찾기 셀
- `MineCounter`: 남은 지뢰 개수 표시
- `Timer`: 시작 후 현재까지 걸린 시간 표시
- `ResetButton`: 게임 초기화 버튼
- `FailModal`: 실패했음을 알리고 다시 시작을 알리는 모달
- `CompleteModal`: 성공을 알리고 기록을 표시 랭킹 진입시 아이디 입력
- `Rank`: 기록 순위표 표시
- `Guide`: 게임 설명 표시

### 2. 상태 값 설계

구현 시작 전 필요한 상태 값들이 어떤 것들이 있을까 생각해보았습니다.

상태 관리는 전역 상태 관리 라이브러리를 따로 사용하지 않기로 결정하였습니다.

앱 규모가 크지 않아서 `Prop drilling`이 복잡하게 발생하지는 않을 것 같았습니다.

```javascript
// 앱 State
{
  mines: CellState[][]; // 지뢰 판의 상태를 2차원 배열로 관리
  timer: number;  // 시간 값 초 단위
  isComplete: boolean;  // 성공시 Complete 모달 띄워주기
  isFail: boolean;  // 성공시 Fail 모달 띄워주기
  rank: Record[]; // 랭킹 기록
}

// CellState
// number로 표시하면 헷갈릴 수 있을 것 같아 string 값들로 표현
type CellState = "none" | "mine" | "flag";

// Record
interface Record {
  name: string; // 이름
  time: number; // 시간 값 초 단위
}

```

### 3. 구현 순서 설계

1. `MineSweeper`와 `Cell` 컴포넌트 동작 구현
2. `MineCounter` 컴포넌트와 깃발 기능 구현
3. `ResetButton` 컴포넌트
4. `Timer` 컴포넌트
5. `FailModal` 컴포넌트
6. `CompleteModal` 컴포넌트
7. 랭킹 관련 기능
8. 게임 설명 표시
